<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, minimal-ui" />
    <title>U.S. Presidential Election Results</title>
    <!-- <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto" /> -->
    <!-- include Tailwind CSS -->
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.16/dist/tailwind.min.css" rel="stylesheet" />
    <link href="https://cdn.jsdelivr.net/npm/@mdi/font@5.x/css/materialdesignicons.min.css" rel="stylesheet" />
    <link href="https://cdn.jsdelivr.net/npm/vuetify@2.x/dist/vuetify.min.css" rel="stylesheet" />
    <style>
        /* hide scroll bar */
        html {
            overflow-y: auto;
        }

        body {
            font-family: "Arial", sans-serif !important;
        }

        .nation,
        .state,
        .county {
            fill: none;
            stroke: #000000;
            pointer-events: none;
        }

        .nation {
            stroke-width: 0.4px;
        }

        .state {
            stroke-width: 0.4px;
        }

        .county {
            stroke: #000000;
            stroke-width: 0.1px;
            pointer-events: auto;
            cursor: pointer;
        }

        .background {
            fill: #fdfcfc;
            fill-opacity: 0.7;
        }

        .bar text {
            font-size: 10px;
        }

        .bar rect {
            stroke: #000000;
            stroke-width: 0.5px;
        }

        #county-legend {
            text-anchor: middle;
        }

        /* John A. details Gomez dynamic details bar  */
        #details {
            z-index: 999;
        }

        #details .title {
            font-size: 1.25vmin;
        }

        .e-title {
            font-size: 1.5vmin;
            font-weight: 700;
        }

        /* custom tooltip */
        .tooltip {
            top: 100px;
            left: 100px;
            /* -moz-border-radius: 5px;
            border-radius: 5px; */
            /*border: 2px solid #000;*/
            box-shadow: -4px 0 12px 0 rgba(0, 0, 0, 0.05);
            background: #ffffff;
            background-color: #fff;
            border: 1px solid #ccc;
            border-radius: 3px;
            opacity: 1;
            /* color: white; */
            padding: 10px;
            /* min-width: 375px; */
            min-width: 36.75vmin;
            font-family: "Arial", sans-serif;
            font-size: 1.25vmin;
            line-height: 18pt;
            font-weight: lighter;
            visibility: visible;
        }

        .tooltip.right::before {
            content: "";
            display: block;
            width: 0;
            height: 0;
            position: absolute;
            opacity: 0.9;
            border-top: 8px solid transparent;
            border-bottom: 8px solid transparent;
            /* border-left: 8px solid #333; */
            right: -8px;
            top: 35px;
            /* arbitrarily set */
        }

        .tooltip.left::before {
            content: "";
            display: block;
            width: 0;
            height: 0;
            position: absolute;
            opacity: 0.9;
            border-top: 8px solid transparent;
            border-bottom: 8px solid transparent;
            left: -8px;
            /* border-right: 8px solid #333; */
            top: 35px;
            /* arbitrarily set */
        }

        /* tooltip table */
        .tooltip-table {
            /* table-layout: fixed; */
            width: 100%;
            /* max-width: 380px; */
            /* min-width: 375px; */
            max-width: 36.75vmin;
            white-space: nowrap;
            border-collapse: collapse;
        }

        .tooltip-table tr:not(:nth-child(1)) {
            border-top: 0.5px solid #ccc;
            border-collapse: collapse;
        }

        .tooltip-table td:not(:nth-child(1)) {
            padding-left: 3px;
        }

        .tooltip-table td:nth-child(1) {
            width: 1%;
        }

        /* state table */
        .highlighted-cell {
            background-color: #86a1c1;
            color: white;
            /* Adjust text color for better readability */
            font-weight: bold;
        }

        /* reset button */
        /* taken from http://materialdesignblog.com/creating-a-simple-material-design-action-button-with-css/ */
        /* uses Material Design principles, which is a plus */
        .fab {
            width: 70px;
            height: 70px;
            background-color: #095591;
            border-radius: 50%;
            box-shadow: 0 6px 10px 0 #666;
            transition: all 0.1s ease-in-out;

            font-size: 50px;
            color: #ffffff;
            text-align: center;
            line-height: 70px;

            position: fixed;
            right: 185px;
            bottom: 110px;

            cursor: pointer;

            z-index: 100;
        }

        .fab:hover {
            box-shadow: 0 6px 14px 0 #666;
            transform: scale(1.05);
        }

        .v-btn--fab.v-btn--absolute,
        .v-btn--fab.v-btn--fixed {
            z-index: 5;
        }

        .v-btn--absolute.v-btn--top,
        .v-btn--fixed.v-btn--top {
            top: 55px;
        }

        /* scaling SVG */
        /* .scaling-svg-container {
            position: relative;
            height: 0;
            width: 100%;
            padding: 0
        }
        
        .scaling-svg {
            position: absolute;
            height: 99%;
            width: 100%;
            left: 0;
            top: 0
        } */
    </style>
</head>

<body>
    <div id="app">
        <v-app>
            <v-app-bar app elevation="1" color="#095591" dark>
                <v-toolbar-title>United States Presidential Election Results by County,
                    2024</v-toolbar-title>

                <v-spacer></v-spacer>
                <v-btn class="mx-4" icon href="https://github.com/tonmcg" target="_blank">
                    <v-icon large>mdi-github</v-icon>
                </v-btn>
                <v-btn class="mx-4" icon href="https://x.com/tonmcg" target="_blank">
                    <v-icon large>mdi-twitter</v-icon>
                </v-btn>
                <v-btn class="mx-4" icon href="https://www.linkedin.com/in/tonmcg" target="_blank">
                    <v-icon large>mdi-linkedin</v-icon>
                </v-btn>
                <v-btn class="mx-4" icon href="https://www.emdata.ai" target="_blank">
                    <v-img alt="emdata Logo" src="https://avatars1.githubusercontent.com/u/58564118?s=200&v=4"
                        width="36px" />
                </v-btn>
            </v-app-bar>

            <v-main>
                <v-container fluid>
                    <div class="tooltip" style="position: absolute; z-index: 10; visibility: hidden;"></div>
                    <v-card tile>
                        <v-card-title>
                            <p class="text-h4">
                                Map of United States Counties and Legislative Districts
                            </p>
                        </v-card-title>
                        <v-card-subtitle class="text-subtitle-1">
                            <v-row>
                                <v-col>
                                    <span>Hover over and click on both the map and table to explore</span>
                                </v-col>
                                <v-col>
                                    <div class="flex justify-end">
                                        <div>
                                            <label class="block text-gray-700 font-medium mb-2">Select map</label>
                                            <div class="flex space-x-4" @change="renderMap">
                                                <label class="inline-flex items-center">
                                                    <input type="radio" name="mapType" value="updatePaths"
                                                        v-model="selectedMap"
                                                        class="form-radio text-blue-600 focus:ring-blue-500 focus:ring-2" />
                                                    <span class="ml-2 text-gray-700">Choropleth (filled)</span>
                                                </label>
                                                <label class="inline-flex items-center">
                                                    <input type="radio" name="mapType" value="updateCircles"
                                                        v-model="selectedMap"
                                                        class="form-radio text-blue-600 focus:ring-blue-500 focus:ring-2" />
                                                    <span class="ml-2 text-gray-700">Dot Density</span>
                                                </label>
                                            </div>
                                        </div>
                                    </div>
                                </v-col>
                            </v-row>
                        </v-card-subtitle>
                        <v-card-text>
                            <v-row>
                                <v-col cols="2">
                                    <!-- Tailwind-styled HTML Table -->
                                    <div
                                        :class="`max-h-[${map.height}px] overflow-auto border border-gray-300 rounded-lg`">
                                        <table class="min-w-full table-auto border-collapse">
                                            <thead>
                                                <tr>
                                                    <th colspan="2"
                                                        class="px-2 py-1 bg-gray-200 text-gray-700 text-center border-b border-gray-300">
                                                        State
                                                    </th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                <tr v-for="(stateRow, rowIndex) in splitStates" :key="rowIndex">
                                                    <td v-for="state in stateRow" :key="state.id"
                                                        :class="{ 'bg-blue-300 text-white': state.id === activeStateId }"
                                                        class="px-2 py-1 text-center cursor-pointer hover:bg-blue-100 border-b border-gray-300"
                                                        @click="toggleStateFilter(state)">
                                                        {{ state.name }}
                                                    </td>
                                                </tr>
                                            </tbody>
                                        </table>
                                    </div>
                                </v-col>
                                <v-col cols="9">
                                    <div
                                        :class="`max-h-[${map.height}px] overflow-auto border border-gray-300 rounded-lg`">
                                        <svg></svg>
                                        <div class="fab" style="opacity: 0;"> ↺ </div>
                                    </div>
                                </v-col>
                            </v-row>
                        </v-card-text>
                        <v-card-actions>
                            <v-row class="align-center">
                                <v-col>
                                    <span class="text-body-2">
                                        Sources:
                                        <a href="https://www.foxnews.com/elections/2024/general-results"
                                            target="_blank"><em>Fox
                                                News</em></a>,
                                        <a href="https://electionresults.dcboe.org/election_results/2024-General-Election"
                                            target="_blank"><em>District of Columbia Board of
                                                Elections</em></a>, and
                                        <a href="https://www.elections.alaska.gov/enr/" target="_blank"><em>Alaska
                                                Division of Elections</em></a>.
                                        <br />Data compiled by:
                                        <a href="https://github.com/tonmcg/US_County_Level_Election_Results_08-24/blob/master/2024_US_County_Level_Presidential_Results.csv"
                                            target="_blank">Tony McGovern</a>.
                                    </span>
                                </v-col>
                                <v-col class="text-body-2 d-flex justify-end" cols="auto">
                                    <span>
                                        Alaska data last updated: {{ alaska.lastupdated }}.
                                        <br />Washington D.C. data last updated: {{ dc.lastupdated }}.
                                        <br />Continental U.S. data last updated: {{ continental.lastupdated }}.

                                    </span>
                                </v-col>
                            </v-row>
                        </v-card-actions>
                    </v-card>
                </v-container>
                <div class="fixed inset-0 flex items-center justify-center bg-gray-800 bg-opacity-50 z-50"
                    v-if="!countyFips.length">
                    <svg class="animate-spin h-32 w-32 text-blue-500" xmlns="http://www.w3.org/2000/svg" fill="none"
                        viewBox="0 0 24 24">
                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="1">
                        </circle>
                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8v4a4 4 0 00-4 4H4z"></path>
                    </svg>
                </div>
            </v-main>
            <footer class="bg-gray-600 text-white">
                <div class="flex justify-center items-center py-4">
                    <span>{{ new Date().getFullYear() }} — <strong>Tony McGovern</strong></span>
                </div>
            </footer>
        </v-app>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/vue@2.x/dist/vue.js" type="text/javascript"></script>
    <script src="https://cdn.jsdelivr.net/npm/vuetify@2.x/dist/vuetify.js" type="text/javascript"></script>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.7.1/dist/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/danfojs@1.1.2/lib/bundle.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js" type="text/javascript"></script>
    <script src="https://unpkg.com/topojson@3" type="text/javascript"></script>
    <script defer type="text/javascript">
        "use strict";

        new Vue({
            el: "#app",
            vuetify: new Vuetify(),
            data: () => ({
                domain: [-1, 1], // set the domain for all scales from -1 to 1
                tooltip: {
                    visibility: "hidden",
                    position: { x: 0, y: 0 },
                    content: "",
                },
                selectedMap: "updateCircles",
                activeStateId: null, // Tracks the currently active state
                gopVotes: 0,
                demVotes: 0,
                gopShare: 0,
                demShare: 0,
                districtObj: {},
                countyFips: [],
                states: [],
                geographies: {
                    censusYear: 2024, // base year for the county gazetteer files
                    suzeraintyFips: ["02", "11", "60", "66", "69", "72", "74", "78"],
                },
                alaska: {
                    lastupdated: ""
                },
                dc: {
                    lastupdated: ""
                },
                continental: {
                    lastupdated: new Date().toLocaleString(),
                },
                map: {
                    width: window.innerWidth * 2 / 3, // 3/4 of the innerWidth of the window,
                    height: window.innerHeight * 5 / 8 // 5/8 of the innerHeight of the window,
                },
                transition: {
                    duration: 1000,
                },
            }),
            computed: {
                color: function () {
                    return d3
                        .scaleSequential()
                        .interpolator(d3.interpolateRdBu)
                        .domain(this.domain);
                },
                wScale: function () {
                    return d3
                        .scaleLinear()
                        .domain(this.domain)
                        .range([-this.map.width / 3, this.map.width / 3]);
                },
                path: function () {
                    return d3.geoPath().projection(null);
                },
                sequentialScale: function () {
                    return d3
                        .scaleSequential()
                        .interpolator(d3.interpolateRdBu)
                        .domain(this.domain);
                },
                // Split states into rows with two columns
                splitStates: function () {
                    const sorted_states = this.states.length < 51 ? [] : this.states.sort((a, b) => a.name.localeCompare(b.name));

                    const split_states = sorted_states.reduce((rows, state, index) => {
                        if (index % 2 === 0) rows.push([]);
                        rows[rows.length - 1].push(state);
                        return rows;
                    }, []);

                    return split_states;
                },
            },
            mounted: async function () {
                const censusCounties = await this.getCensusCounties();
                const censusStates = await this.getCensusStates();
                const censusGeographies = this.mergeCensusGeographies(
                    censusCounties,
                    censusStates
                );
                const dcGeographies = await this.getDCGeographies();
                await this.fetchDCResults(dcGeographies);
                await this.fetchDCUpdatedDate();
                const akGeographies = await this.getAlaskaGeographies();
                await this.fetchAlaskaResults(akGeographies);
                await this.fetchElectionResults(censusStates, censusGeographies);
                this.calculateMetrics(); // calculate computed properties
                const { us } = await this.fetchUSGeography();
                this.initializeMap(us);
                this.renderMap();
                this.createBars();
                this.bindHover();
                if (this.countyFips.length > 40) { // arbitrarily set threshold
                    setTimeout(() => {
                        this.selectedMap = "updatePaths";
                        this.renderMap();
                    }, 3000);
                }
            },
            methods: {
                async getCensusCounties() {
                    const that = this;
                    // Enter base year for the county gazetteer files
                    const censusYear = this.geographies.censusYear;

                    // Base URL where all the county gazetteer files live
                    const gazetteerUrl = `https://us-election-server-2ae36243a2a4.herokuapp.com/census/gazetteer/${censusYear}`;

                    const censusCounties = async function parseCountyGeographyData(censusGazCounties) {

                        // Function to fetch and parse a single county file
                        async function fetchCountyFile(countyFileName) {
                            const response = await fetch(gazetteerUrl + '/' + countyFileName);
                            const csvText = await response.text();
                            const parsedData = d3.dsvFormat('\t').parse(csvText, function (d) {
                                return {
                                    geoid: d['GEOID'],
                                    c_county_name: d['NAME']
                                };
                            });
                            return parsedData;
                        }

                        // Read each county file CSV
                        const censusCountyFilesPromises = censusGazCounties.map(file => fetchCountyFile(file.county_file_name));
                        const censusCountyFiles = await Promise.all(censusCountyFilesPromises);

                        // Combine into a single array
                        const censusCounties = [].concat(...censusCountyFiles);

                        // Create state FIPS codes from the 5-digit 'geoid'
                        censusCounties.forEach(county => {
                            county.state_fips = county.geoid.slice(0, 2);
                        });

                        // Log the result
                        console.log('Shape:', censusCounties.length);
                        console.log('Data Types:', {
                            geoid: typeof censusCounties[0].geoid,
                            c_county_name: typeof censusCounties[0].c_county_name,
                            state_fips: typeof censusCounties[0].state_fips
                        });
                        console.log('First 100 Entries:', censusCounties.slice(0, 100));

                        return censusCounties;
                    }

                    const censusGazCounties = async function getCountyGazFiles() {
                        // Make an HTTP request for the page
                        const response = await fetch(gazetteerUrl, {
                            method: 'GET',
                            headers: { "Accept": "application/json" }
                        });

                        // Parse the page and return a DOM tree
                        const pageContent = await response.text();
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(pageContent, 'text/html');

                        // Use XPath to return a list of link texts ('a' elements within the 'table' element) from the DOM
                        const xpathResult = doc.evaluate('//td/a/text()', doc, null, XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
                        const gazetteerFiles = [];
                        for (let i = 0; i < xpathResult.snapshotLength; i++) {
                            gazetteerFiles.push(xpathResult.snapshotItem(i).nodeValue);
                        }

                        // Filter the list to return only county file names
                        const countyFiles = gazetteerFiles.filter(c => /.*counties.*\.txt/.test(c));

                        // Convert the list to an array of objects
                        const countyFilesSeries = countyFiles.map(fileName => ({ county_file_name: fileName }));

                        // Filter out Alaska and these Suzerainty entities
                        const censusGazCounties = countyFilesSeries.filter(file => {
                            const match = file.county_file_name.match(/_(\d{2})\.txt/);
                            return match && !that.geographies.suzeraintyFips.includes(match[1]);
                        });

                        // Log the result
                        console.log('Shape:', censusGazCounties.length);
                        console.log('Data Types:', censusGazCounties.map(file => typeof file.county_file_name));
                        console.log('First 100 Entries:', censusGazCounties.slice(0, 100));

                        return censusGazCounties;
                    }

                    return await censusCounties(await censusGazCounties());
                },
                async getCensusGeograhpies() {
                    const censusGeographies = await d3.csv(
                        "2024_us_census_geographies.csv"
                    );

                    return censusGeographies;
                },
                async getCensusStates() {

                    // Fetch the JSON data
                    const url = "https://us-election-server-2ae36243a2a4.herokuapp.com/census/state_data";
                    const response = await fetch(url, { method: "GET" });
                    const data = await response.text();
                    // Parse the CSV data using d3.dsv
                    const allCensusStates = d3.dsvFormat('|').parse(data, function (d) {
                        return {
                            state_fips: d.STATE,
                            state_abbr: d.STUSAB,
                            c_state_name: d.STATE_NAME
                        };
                    });

                    // Filter out Alaska and these Suzerainty entities
                    const censusStates = allCensusStates.filter(state => !this.geographies.suzeraintyFips.includes(state.state_fips));

                    this.states = censusStates.map(state => ({
                        id: state.state_fips,
                        name: state.c_state_name
                    }));

                    return censusStates;
                },
                mergeCensusGeographies(censusCounties, censusStates) {
                    // Convert the input arrays to DataFrames
                    const censusCountiesDf = new dfd.DataFrame(censusCounties);
                    const censusStatesDf = new dfd.DataFrame(censusStates);

                    // Select the relevant columns from censusStates
                    const selectedCensusStatesDf = censusStatesDf.loc({
                        columns: ["state_fips", "c_state_name"]
                    });

                    // Perform a left join on 'state_fips'
                    const countyStateDf = dfd.merge({
                        left: censusCountiesDf,
                        right: selectedCensusStatesDf,
                        on: ["state_fips"],
                        how: "left"
                    });

                    // Drop the 'state_fips' column
                    const censusGeographies = countyStateDf.drop({ columns: ["state_fips"], axis: 1 });

                    // Log the shape and data types of the resulting DataFrame
                    console.log("Shape:", censusGeographies.shape);
                    console.log("Data Types:", censusGeographies.ctypes);

                    // Print the first 100 rows of the resulting DataFrame
                    censusGeographies.head(100).print();

                    // convert back to JSON and return
                    return dfd.toJSON(censusGeographies);
                },
                async getDCGeographies() {

                    // Download the zip file content into memory
                    const url = `https://us-election-server-2ae36243a2a4.herokuapp.com/census/gazetteer/${this.geographies.censusYear}/dc_sldu`;
                    const response = await fetch(url, { method: "GET" });
                    const arrayBuffer = await response.arrayBuffer();
                    const nationalGazetteerZip = new Uint8Array(arrayBuffer);

                    // Open the zip file from the in-memory content
                    const zip = await JSZip.loadAsync(nationalGazetteerZip);
                    const unzippedFiles = Object.keys(zip.files);

                    // Find the tab-delimited text file (assuming it's a .txt file)
                    let tabDelimitedFile = null;
                    for (const file of unzippedFiles) {
                        if (file.endsWith(".txt")) {
                            tabDelimitedFile = file;
                            break;
                        }
                    }

                    if (!tabDelimitedFile) {
                        console.error("No tab-delimited text file found.");
                        return;
                    }

                    // Read the tab-delimited text file content
                    const fileContent = await zip.file(tabDelimitedFile).async("string");

                    // Parse the tab-delimited text file using d3
                    const nationalsldusts = d3.dsvFormat('\t').parse(fileContent, function (d) {
                        return {
                            c_state_name: "District of Columbia", // Add District of Columbia name to state_name column
                            geoid: d['GEOID'],
                            c_sldust_name: d['NAME']
                        };
                    });
                    // Convert the national sldusts data to a DataFrame
                    const nationalsldusts_df = new dfd.DataFrame(nationalsldusts, {
                        index: null,
                        columns: ["c_state_name", "geoid", "c_sldust_name"],
                        dtypes: ["string", "string", "string"]
                    });

                    // filter the national sldusts dataframe for District of Columbia and reset the index
                    let dcGeographies = nationalsldusts_df.loc({
                        rows: nationalsldusts_df["geoid"].map(
                            (geo) => geo.startsWith("11")
                        ),
                    }).resetIndex({ drop: true });

                    // Reorder columns
                    dcGeographies = dcGeographies.loc({
                        columns: ["c_state_name", "geoid", "c_sldust_name"]
                    });
                    // Log the shape and data types of the resulting DataFrame
                    console.log("Shape:", dcGeographies.shape);
                    console.log("Data Types:", dcGeographies.ctypes);

                    // Print the first 100 rows of the resulting DataFrame
                    dcGeographies.head(100).print();

                    this.states.push({
                        id: "11",
                        name: "District of Columbia"
                    });

                    // convert back to JSON and return
                    return dfd.toJSON(dcGeographies);
                },
                async getAlaskaGeographies() {

                    // Download the zip file content into memory
                    const url = `https://us-election-server-2ae36243a2a4.herokuapp.com/census/gazetteer/${this.geographies.censusYear}/ak_sldl`;
                    const response = await fetch(url, { method: "GET" });
                    const arrayBuffer = await response.arrayBuffer();
                    const nationalGazetteerZip = new Uint8Array(arrayBuffer);

                    // Open the zip file from the in-memory content
                    const zip = await JSZip.loadAsync(nationalGazetteerZip);
                    const unzippedFiles = Object.keys(zip.files);

                    // Find the tab-delimited text file (assuming it's a .txt file)
                    let tabDelimitedFile = null;
                    for (const file of unzippedFiles) {
                        if (file.endsWith(".txt")) {
                            tabDelimitedFile = file;
                            break;
                        }
                    }

                    if (!tabDelimitedFile) {
                        console.error("No tab-delimited text file found.");
                        return;
                    }

                    // Read the tab-delimited text file content
                    const fileContent = await zip.file(tabDelimitedFile).async("string");

                    // Parse the tab-delimited text file using d3
                    const nationalSldlsts = d3.dsvFormat('\t').parse(fileContent, function (d) {
                        return {
                            c_state_name: "Alaska", // Add Alaska name to state_name column
                            geoid: d['GEOID'],
                            c_sldlst_name: d['NAME']
                        };
                    });
                    // Convert the national sldlsts data to a DataFrame
                    const nationalSldlsts_df = new dfd.DataFrame(nationalSldlsts, {
                        index: null,
                        columns: ["c_state_name", "geoid", "c_sldlst_name"],
                        dtypes: ["string", "string", "string"]
                    });

                    // filter the national sldlsts dataframe for Alaska and reset the index
                    let akGeographies = nationalSldlsts_df.loc({
                        rows: nationalSldlsts_df["geoid"].map(
                            (geo) => geo.startsWith("02")
                        ),
                    }).resetIndex({ drop: true });

                    // Reorder columns
                    akGeographies = akGeographies.loc({
                        columns: ["c_state_name", "geoid", "c_sldlst_name"]
                    });
                    // Log the shape and data types of the resulting DataFrame
                    console.log("Shape:", akGeographies.shape);
                    console.log("Data Types:", akGeographies.ctypes);

                    // Print the first 100 rows of the resulting DataFrame
                    akGeographies.head(100).print();

                    this.states.push({
                        id: "02",
                        name: "Alaska"
                    });

                    // convert back to JSON and return
                    return dfd.toJSON(akGeographies);
                },
                async getFoxStateResults(stateAbbr) {
                    // Request JSON data for the specified state
                    const url = `https://feeds-elections.foxnews.com/archive/politics/elections/2024/3/2024_Generals/President/${stateAbbr}/county_level_results/file.json`;
                    const response = await fetch(url);
                    const data = await response.json();

                    // Process lookup table
                    const lookupCounties = data.lookup.counties;
                    const lookupArray = Object.entries(lookupCounties).map(
                        ([key, value]) => ({
                            countyId: key.toString(),
                            county_fips: value.fipsCode.toString().padStart(5, "0"),
                        })
                    );

                    // Process results table
                    const results = data.results;
                    const rows = [];
                    results.forEach((result) => {
                        const partyName = result.candidate.partyName;
                        result.countyVotes.forEach((voteData) => {
                            rows.push({
                                partyName,
                                countyId: voteData.countyId.toString(),
                                count: voteData.votes.count,
                            });
                        });
                    });

                    const candidateColumns = ["partyName", "countyId", "count"];
                    const candidateDtypes = ["string", "string", "int32"];
                    // Convert rows to a DataFrame (using danfo.js)
                    const candidateDf = new dfd.DataFrame(rows, {
                        index: null,
                        columns: candidateColumns,
                        dtypes: candidateDtypes,
                    });
                    // Group by county and calculate total votes
                    const groupedByCounty = candidateDf
                        .groupby(["countyId"])
                        .col(["count"])
                        .sum();
                    groupedByCounty.rename(
                        { count_sum: "total_votes" },
                        { inplace: true }
                    );
                    // Force 'countyId' to string
                    const newGroupedByCounty = new dfd.DataFrame(
                        {
                            countyId: groupedByCounty["countyId"].$data.map(String), // Convert to string explicitly
                            total_votes: groupedByCounty["total_votes"].$data, // Preserve total_votes column
                        },
                        {
                            index: null,
                            columns: ["countyId", "total_votes"],
                            dtypes: ["string", "int32"],
                        }
                    );

                    // Filter results for Democrat and Republican candidates only
                    const filteredDf = candidateDf.loc({
                        rows: candidateDf["partyName"].map(
                            (party) => party === "Democrat" || party === "Republican"
                        ),
                    });
                    // Pivot the DataFrame
                    // Group by 'countyId' and 'partyName' to aggregate vote counts
                    const groupedDf = filteredDf
                        .groupby(["countyId", "partyName"])
                        .agg({ count: "sum" });

                    // Convert the grouped DataFrame into an object for reshaping
                    const groupedData = groupedDf.values.map((row) => ({
                        countyId: row[0],
                        partyName: row[1],
                        count: row[2],
                    }));

                    // Reshape the data into pivot-like format
                    const pivotMap = {};
                    groupedData.forEach((row) => {
                        const { countyId, partyName, count } = row;
                        if (!pivotMap[countyId]) {
                            pivotMap[countyId] = { countyId, votes_dem: 0, votes_gop: 0 };
                        }
                        if (partyName === "Democrat") {
                            pivotMap[countyId].votes_dem = count;
                        } else if (partyName === "Republican") {
                            pivotMap[countyId].votes_gop = count;
                        }
                    });

                    const pivotColumns = ["countyId", "votes_dem", "votes_gop"];
                    const pivotDtypes = ["string", "int32", "int32"];
                    // Convert pivoted object back into a DataFrame
                    const pivotedData = Object.values(pivotMap);
                    const pivotedDf = new dfd.DataFrame(pivotedData, {
                        index: null,
                        columns: pivotColumns,
                        dtypes: pivotDtypes,
                    });

                    // Fill NaN values with 0
                    pivotedDf.fillNa(0);
                    pivotedDf.rename(
                        { Democrat: "votes_dem", Republican: "votes_gop" },
                        { inplace: true }
                    );

                    // Merge total votes and pivoted results
                    // const resultsDf = this.mergeDataFrames(
                    //   [pivotedDf, newGroupedByCounty],
                    //   "left",
                    //   "countyId"
                    // );
                    // I can't get danfo.js merge to work, so I'll use a merge function I created
                    const resultsDf = dfd.merge({
                        left: pivotedDf,
                        right: newGroupedByCounty,
                        on: ["countyId"],
                        how: "left",
                    });

                    const lookupColumns = ["countyId", "county_fips"];
                    const lookupDtypes = ["string", "string"];
                    // Convert lookupArray to a DataFrame
                    const lookupDf = new dfd.DataFrame(lookupArray, {
                        index: null,
                        columns: lookupColumns,
                        dtypes: lookupDtypes,
                    });

                    // Merge with lookup to get FIPS codes
                    // const resultsLookupDf = this.mergeDataFrames(
                    //   [resultsDf, lookupDf],
                    //   "left",
                    //   "countyId"
                    // );
                    // I can't get danfo.js merge to work, so I'll use a merge function I created
                    const resultsLookupDf = dfd.merge({
                        left: resultsDf,
                        right: lookupDf,
                        on: ["countyId"],
                        how: "left",
                    });

                    // Reorder columns
                    const reorderedDf = resultsLookupDf.loc({
                        columns: ["county_fips", "total_votes", "votes_dem", "votes_gop"],
                    });

                    // convert to JSON and return final results
                    return dfd.toJSON(reorderedDf);
                },
                async fetchElectionResults(censusStates, censusGeographies) {
                    try {
                        // Define state abbreviations while leaving off Alaska
                        const stateAbbrs = censusStates
                            .filter((state) => state.state_abbr !== "AK")
                            .map((state) => state.state_abbr);

                        // Retrieve results for each state asynchronously
                        const contiguousFoxStateResults = await Promise.all(
                            stateAbbrs.map(
                                async (stateAbbr) => await this.getFoxStateResults(stateAbbr)
                            )
                        );

                        // combine all state data
                        let contiguousFoxElectionResults =
                            contiguousFoxStateResults.flat(); // Flatten the array of state results

                        const countyResults = {};

                        // add geographic data and calculated metrics
                        contiguousFoxElectionResults = contiguousFoxElectionResults.map(
                            (d) => {
                                const county_fips = String(d.county_fips); // Convert to string
                                const county_attributes = censusGeographies.filter(
                                    (geography) => geography.geoid === county_fips
                                )[0];
                                const result = {
                                    county_fips: county_fips,
                                    // add census geographies
                                    State: county_attributes.c_state_name,
                                    County: county_attributes.c_county_name,
                                    // add calculated columns
                                    ["% of Total Vote, GOP"]: d.votes_gop / d.total_votes,
                                    ["% of Total Vote, Dem."]: d.votes_dem / d.total_votes,
                                    ["Percentage Point Difference"]:
                                        ((d.votes_gop - d.votes_dem) / d.total_votes) * -1,
                                    ["Winner"]: d.votes_dem > d.votes_gop ? "Dem." : "GOP",
                                    ["GOP"]: d.votes_gop,
                                    ["Dem."]: d.votes_dem,
                                    ["Total Votes"]: d.total_votes,
                                    ["Margin"]: d.votes_gop - d.votes_dem,
                                    ["Abs. Margin"]: Math.abs(d.votes_gop - d.votes_dem),
                                    Size: Math.sqrt(Math.abs(d.votes_gop - d.votes_dem)) * 0.02,
                                };
                                countyResults[county_fips] = result;
                                return result;
                            }
                        );

                        // add county fips to array and add results to districtObj
                        this.countyFips = this.countyFips.concat(
                            Object.keys(countyResults)
                        );
                        this.districtObj = { ...this.districtObj, ...countyResults };
                    } catch (error) {
                        console.error("Error fetching Alaska results:", error);
                    }
                },
                async fetchDCResults(dcGeographies) {

                    async function getWardElectionResults(wardNumber) {
                        // Fetch the JSON data from the API
                        const url = `https://us-election-server-2ae36243a2a4.herokuapp.com/dc/results/${wardNumber}`;
                        const response = await fetch(url);
                        const data = await response.json();

                        // Filter rows where OfficeName is "ELECTORS OF PRESIDENT AND VICE PRESIDENT OF THE UNITED STATES"
                        const dcPresidentResults = data.filter(record => record.OfficeName === "ELECTORS OF PRESIDENT AND VICE PRESIDENT OF THE UNITED STATES");

                        // Flatten the JSON to extract required information
                        const rows = dcPresidentResults[0].ElectionData.map(candidate => ({
                            WardNumber: wardNumber,
                            PartyCode: candidate.PartyCode,
                            votes: candidate.Votes,
                            total_votes: candidate.TotalVotes
                        }));

                        // Filter for DEM and REP candidates
                        const filteredCandidates = rows.filter(row => ["DEM", "REP"].includes(row.PartyCode));

                        // Pivot the data to separate GOP and DEM votes into their own columns
                        const pivotData = {};
                        filteredCandidates.forEach(row => {
                            if (!pivotData[row.WardNumber]) {
                                pivotData[row.WardNumber] = { Ward: `Ward ${row.WardNumber}`, total_votes: row.total_votes, votes_gop: 0, votes_dem: 0 };
                            }
                            if (row.PartyCode === "REP") {
                                pivotData[row.WardNumber].votes_gop = row.votes;
                            } else if (row.PartyCode === "DEM") {
                                pivotData[row.WardNumber].votes_dem = row.votes;
                            }
                        });

                        const dcWardResults = Object.values(pivotData);

                        return dcWardResults;
                    }

                    // Extract the ward numbers from the c_sldust_name column
                    const wards = dcGeographies.map(geo => geo.c_sldust_name.match(/Ward (\d+)/)[1]);

                    // Retrieve results for each ward
                    const dcResultsPromises = wards.map(wardNumber => getWardElectionResults(wardNumber));
                    const dcResults = await Promise.all(dcResultsPromises);

                    // Combine all ward dataframes
                    const dcResultsFlat = dcResults.flat();

                    const countyResults = {};

                    // Merge with legislative districts
                    const dcResultsGeographies = dcResultsFlat.map(row => {
                        const county_attributes = dcGeographies.find(geo => geo.c_sldust_name === row.Ward);
                        const county_fips = String(county_attributes.geoid); // Convert to string
                        const result = {
                            // add census geographies
                            State: county_attributes
                                ? county_attributes.c_state_name
                                : null,
                            County: county_attributes
                                ? county_attributes.c_sldust_name
                                : null,
                            // add calculated columns
                            ["% of Total Vote, GOP"]: row.votes_gop / row.total_votes,
                            ["% of Total Vote, Dem."]: row.votes_dem / row.total_votes,
                            ["Percentage Point Difference"]:
                                ((row.votes_gop - row.votes_dem) / row.total_votes) * -1,
                            ["Winner"]: row.votes_dem > row.votes_gop ? "Dem." : "GOP",
                            ["GOP"]: row.votes_gop,
                            ["Dem."]: row.votes_dem,
                            ["Total Votes"]: row.total_votes,
                            ["Margin"]: row.votes_gop - row.votes_dem,
                            ["Abs. Margin"]: Math.abs(row.votes_gop - row.votes_dem),
                            Size:
                                Math.sqrt(Math.abs(row.votes_gop - row.votes_dem)) * 0.02,
                        };
                        countyResults[county_fips] = result;
                        return result;
                    });

                    // add county fips to array and add results to districtObj
                    this.countyFips = this.countyFips.concat(
                        Object.keys(countyResults)
                    );
                    this.districtObj = { ...this.districtObj, ...countyResults };
                },
                async fetchDCUpdatedDate() {
                    // Fetch the JSON data from the API
                    const url = `https://us-election-server-2ae36243a2a4.herokuapp.com/dc/results/lastUpdated`;
                    const response = await fetch(url);
                    const data = await response.json();

                    this.dc.lastupdated = new Date(data.LastUpdated).toLocaleString();
                },
                async fetchAlaskaResults(akGeographies) {
                    try {
                        // Fetch the JSON data
                        const url = "https://us-election-server-2ae36243a2a4.herokuapp.com/ak/results/statewide";
                        const response = await fetch(url, { method: "GET" });
                        const data = await response.json();

                        this.alaska.lastupdated = new Date(data.updated).toLocaleString();

                        // Process candidate names
                        let candidateNames = data.candidateNames
                            .map((candidate, index) => ({
                                candidateNumber: index.toString(),
                                Candidate: candidate,
                            }))
                            .filter((candidate) =>
                                ["Harris/Walz (DEM)", "Trump/Vance (REP)"].includes(
                                    candidate.Candidate
                                )
                            );

                        // Process contest names
                        let contestNames = data.contestNames
                            .map((contest, index) => ({
                                contestNumber: index.toString(),
                                Contest: contest,
                            }))
                            .filter(
                                (contest) =>
                                    contest.Contest === "U.S. President / Vice President"
                            );

                        // Process districts
                        // Flatten the JSON to extract required information
                        let districts = [];
                        data.districts.forEach((district) => {
                            let houseDistrict = district.number;
                            district.contests.forEach((contest) => {
                                let contestNumber = contest.n.toString();
                                contest.c.forEach((candidate) => {
                                    let candidateNumber = candidate.n.toString();
                                    let votes = candidate.t;
                                    districts.push({
                                        "House District": `State House District ${houseDistrict}`,
                                        contestNumber: contestNumber,
                                        candidateNumber: candidateNumber,
                                        votes: votes,
                                    });
                                });
                            });
                        });

                        // Merge contests and candidates with districts
                        let districtsContestsCandidates = [];
                        districts.forEach((row) => {
                            let contest = contestNames.find(
                                (contest) => contest.contestNumber === row.contestNumber
                            );
                            let candidate = candidateNames.find(
                                (candidate) =>
                                    candidate.candidateNumber === row.candidateNumber
                            );
                            if (contest && candidate) {
                                districtsContestsCandidates.push({
                                    ["House District"]: row["House District"],
                                    Contest: contest.Contest,
                                    Candidate: candidate.Candidate,
                                    votes: row.votes,
                                });
                            }
                        });

                        // Group by House District and calculate total votes
                        let totalVotes = districtsContestsCandidates.reduce(
                            (acc, row) => {
                                acc[row["House District"]] =
                                    (acc[row["House District"]] || 0) + row.votes;
                                return acc;
                            },
                            {}
                        );

                        // Pivot table for party votes
                        let pivot = districtsContestsCandidates.reduce((acc, row) => {
                            if (!acc[row["House District"]]) {
                                acc[row["House District"]] = {
                                    "House District": row["House District"],
                                    votes_gop: 0,
                                    votes_dem: 0,
                                };
                            }
                            if (row.Candidate === "Trump/Vance (REP)") {
                                acc[row["House District"]].votes_gop += row.votes;
                            } else if (row.Candidate === "Harris/Walz (DEM)") {
                                acc[row["House District"]].votes_dem += row.votes;
                            }
                            return acc;
                        }, {});

                        // Convert pivot object to array
                        let pivotArray = Object.values(pivot);

                        // Merge total votes with pivot table
                        pivotArray.forEach((row) => {
                            row.total_votes = totalVotes[row["House District"]];
                        });

                        const countyResults = {};

                        // Merge with legislative districts (assuming ak_geographies is available)
                        let akResultsGeographies = pivotArray.map((row) => {
                            const county_attributes = akGeographies.find(
                                (geo) => geo.c_sldlst_name === row["House District"]
                            );
                            const county_fips = String(county_attributes.geoid); // Convert to string
                            const result = {
                                county_fips: county_fips ? county_fips : null,
                                // add census geographies
                                State: county_attributes
                                    ? county_attributes.c_state_name
                                    : null,
                                County: county_attributes
                                    ? county_attributes.c_sldlst_name
                                    : null,
                                // add calculated columns
                                ["% of Total Vote, GOP"]: row.votes_gop / row.total_votes,
                                ["% of Total Vote, Dem."]: row.votes_dem / row.total_votes,
                                ["Percentage Point Difference"]:
                                    ((row.votes_gop - row.votes_dem) / row.total_votes) * -1,
                                ["Winner"]: row.votes_dem > row.votes_gop ? "Dem." : "GOP",
                                ["GOP"]: row.votes_gop,
                                ["Dem."]: row.votes_dem,
                                ["Total Votes"]: row.total_votes,
                                ["Margin"]: row.votes_gop - row.votes_dem,
                                ["Abs. Margin"]: Math.abs(row.votes_gop - row.votes_dem),
                                Size:
                                    Math.sqrt(Math.abs(row.votes_gop - row.votes_dem)) * 0.02,
                            };
                            countyResults[county_fips] = result;
                            return result;
                        });

                        // add county fips to array and add results to districtObj
                        this.countyFips = this.countyFips.concat(
                            Object.keys(countyResults)
                        );
                        this.districtObj = { ...this.districtObj, ...countyResults };
                    } catch (error) {
                        console.error("Error fetching Alaska results:", error);
                    }
                },
                async fetchUSGeography() {
                    // get county paths and election data
                    const results = await d3.json(
                        "./cartography/2024/us-albers-500k.topojson"
                    );

                    return { us: results };
                },
                initializeMap(us) {
                    const that = this;
                    const width = this.map.width;
                    const height = this.map.height;

                    const zoom = d3
                        .zoom()
                        .scaleExtent([1, 30])
                        .on("zoom", (event) => {
                            const that = this;
                            zoomed(event, that);
                        });

                    // Create the SVG element
                    const svg = d3
                        .select("svg")
                        .attr("viewBox", [0, 0, width, height]) // Use dynamically calculated width and height
                        .attr("width", width) // Set the width of the SVG
                        .attr("height", height) // Set the height of the SVG
                        .on("click", () => resetZoom(that));

                    const g = svg.append("g");

                    // Create background box for zoom
                    g.append("rect")
                        .attr("class", "background")
                        .attr("width", width)
                        .attr("height", height);

                    // Create group for county paths
                    const group = g.append("g")
                        .attr("id", "map");

                    // Define path projection
                    const path = d3.geoPath().projection(null);

                    // Add county paths
                    const countyPath = group
                        .selectAll(".counties")
                        .data(topojson.feature(us, us.objects.wards_districts_counties).features)
                        .enter()
                        .append("path")
                        .attr("class", "county")
                        .attr("d", path)
                        .style("opacity", 1)
                        .on("click", (event, d) => {
                            clicked(event, d, that);
                        });

                    // Add state boundaries
                    group
                        .append("path")
                        .datum(topojson.mesh(us, us.objects.state, (a, b) => a !== b))
                        .attr("class", "state")
                        .attr("d", path);

                    // Add national boundary
                    const nation = group
                        .append("path")
                        .datum(topojson.feature(us, us.objects.nation))
                        .attr("class", "nation")
                        .attr("d", path);

                    // Calculate and apply initial center position
                    const center = [
                        width / 2 - path.centroid(nation.datum())[0], // Center X
                        height / 2 - path.centroid(nation.datum())[1], // Center Y
                    ];

                    // Initialize the map position with the calculated center
                    group.attr("transform", `translate(${center[0]},${center[1]})`);

                    const dotDensity = group
                        .selectAll(".dot")
                        .data(topojson.feature(us, us.objects.wards_districts_counties).features)
                        .enter()
                        .append("circle")
                        .attr("class", "dot")
                        .attr("cx", (d) => {
                            const centroid = path.centroid(d);
                            return !centroid[0] ? null : centroid[0];
                        })
                        .attr("cy", (d) => {
                            const centroid = path.centroid(d);
                            return !centroid[1] ? null : centroid[1];
                        })
                        .attr("r", 0)
                        .style("opacity", 0)
                        .on("click", (event, d) => {
                            clicked(event, d, that);
                        });

                    svg.call(zoom);

                    // create details bar
                    // use John Alexis details Gómez dynamic details bar
                    // https://johndetails.co/
                    const detailsLayer = g
                        .append("g")
                        .attr("id", "details")
                        .attr("transform", "translate(" + (width / 2 - 100) + ", 30)");

                    detailsLayer
                        .append("rect")
                        .attr("class", "background")
                        .attr(
                            "transform",
                            "translate(" + (-this.wScale.range()[1] + 100) + ", -20)"
                        )
                        .attr("width", this.wScale.range()[1] * 2 + 70)
                        .attr("rx", 5)
                        .attr("ry", 5)
                        .attr("height", 60);

                    detailsLayer
                        .append("text")
                        .attr("id", "county-legend")
                        .html("Percentage Share of the Two-party Vote")
                        .attr("transform", "translate(100, 0)");

                    // create zoom event on reset button
                    const fab = d3
                        .select(".fab")
                        .on("click", () => resetZoom(that));

                    // Reset zoom and center map to its original position
                    function resetZoom(that) {
                        svg
                            .transition()
                            .duration(that.transition.duration * (3 / 4))
                            .call(
                                zoom.transform,
                                d3.zoomIdentity.translate(center[0], center[1]).scale(1), // Center projection in the middle of the rect
                                d3.zoomTransform(svg.node()).invert([center[0], center[1]])
                            );
                    }
                    function clicked(event, d, that) {
                        const [[x0, y0], [x1, y1]] = path.bounds(d); // Get bounding box of the selected feature
                        event.stopPropagation();
                        svg
                            .transition()
                            .duration(that.transition.duration * (3 / 4))
                            .call(
                                zoom.transform,
                                d3.zoomIdentity
                                    .translate(width / 2, height / 2) // Center the map on the viewport
                                    .scale(
                                        Math.min(
                                            8,
                                            0.9 / Math.max((x1 - x0) / width, (y1 - y0) / height)
                                        )
                                    )
                                    .translate(-(x0 + x1) / 2, -(y0 + y1) / 2), // Center on the bounds of the clicked feature
                                d3.pointer(event, svg.node())
                            );
                    }

                    function zoomed(event, that) {
                        const duration = that.transition.duration;
                        const { transform } = event;
                        group.attr("transform", transform);
                        group.attr("stroke-width", 1 / transform.k);
                        // hide button if zoomed out
                        if (transform.k > 1 && (transform.x || transform.y !== 0)) {
                            fab
                                .transition()
                                .duration(duration / 2)
                                .style("opacity", 1);
                        } else {
                            fab
                                .transition()
                                .duration(duration / 2)
                                .style("opacity", 0);
                        }
                    }
                },
                renderMap() {
                    if (
                        this.selectedMap &&
                        typeof this[this.selectedMap] === "function"
                    ) {
                        this[this.selectedMap]();
                    } else {
                        console.error("Selected function is not valid");
                    }
                },
                toggleStateFilter(state) {
                    // Check if the clicked state is already active
                    if (this.activeStateId === state.id) {
                        this.activeStateId = null; // Reset the active state
                        this.resetMap(); // Reset the map to its unfiltered state
                    } else {
                        this.activeStateId = state.id; // Set the active state
                        this.filterState(state); // Filter the map
                    }
                },
                resetMap() {
                    // Reset the active state
                    this.activeStateId = null;

                    // Select all county paths
                    const countyPaths = d3.selectAll(".county");

                    // Reset the county paths to their original opacity
                    countyPaths
                        .transition()
                        .duration(this.transition.duration / 2)
                        .style("opacity", 1);

                    // Reset the zoom level and center the map
                    d3.select("svg")
                        .transition()
                        .duration(this.transition.duration / 2)
                        .call(
                            d3.zoom().transform,
                            d3.zoomIdentity.translate(this.map.width / 2, this.map.height / 2).scale(1)
                        );
                },
                filterState(state) {
                    // Assuming you have a way to identify the state in your map data
                    const stateFips = state.id; // or however you identify the state

                    this.activeStateId = stateFips; // Update the active state

                    // Select all county paths
                    const countyPaths = d3.selectAll(".county");

                    // Filter the counties to show only those in the selected state
                    countyPaths
                        .transition()
                        .duration(this.transition.duration / 2)
                        .style("opacity", d => d.id.startsWith(stateFips) ? 1 : 0.1);

                    // Optionally, you can also zoom to the state
                    const stateBoundaries = d3.selectAll(".state").filter(d => d.id === stateFips);
                    if (stateBoundaries.size() > 0) {
                        const [[x0, y0], [x1, y1]] = d3.geoPath().bounds(stateBoundaries.datum());
                        const width = this.map.width;
                        const height = this.map.height;
                        const zoom = d3.zoom().scaleExtent([1, 30]);

                        d3.select("svg")
                            .transition()
                            .duration(this.transition.duration / 2)
                            .call(
                                zoom.transform,
                                d3.zoomIdentity
                                    .translate(width / 2, height / 2)
                                    .scale(Math.min(8, 0.9 / Math.max((x1 - x0) / width, (y1 - y0) / height)))
                                    .translate(-(x0 + x1) / 2, -(y0 + y1) / 2)
                            );
                    }
                },
                calculateMetrics() {
                    this.gopVotes = d3.sum(
                        this.countyFips,
                        (r) => this.districtObj[r]["GOP"]
                    );
                    this.demVotes = d3.sum(
                        this.countyFips,
                        (r) => this.districtObj[r]["Dem."]
                    );
                    this.gopShare = this.gopVotes / (this.gopVotes + this.demVotes);
                    this.demShare = this.demVotes / (this.gopVotes + this.demVotes);
                },
                removePathFill() {
                    // select all county paths
                    const countyPath = d3.selectAll(".county");
                    // remove fill property of county paths
                    countyPath
                        .transition()
                        .duration(this.transition.duration / 2)
                        .style("opacity", 1)
                        .style("fill", (d) => "#ffffff");
                },
                updatePaths() {
                    // first diminish circles
                    this.diminishCircles();
                    // select all county paths
                    const countyPath = d3.selectAll(".county");
                    // update fill property of county paths
                    countyPath
                        .transition()
                        .duration(this.transition.duration / 2)
                        .style("opacity", 1)
                        .style("fill", (d) => {
                            const county = this.districtObj[d.id];
                            return county
                                ? this.color(county["Percentage Point Difference"])
                                : "#ccc";
                        });
                },
                diminishCircles() {
                    // select all county circles
                    const dotDensity = d3.selectAll(".dot");
                    // diminish radius, fill, and opacity properties of county circles
                    dotDensity
                        .transition()
                        .duration(this.transition.duration / 2)
                        .attr("r", 0)
                        .style("opacity", 0);
                },
                updateCircles() {
                    // first remove path fills
                    this.removePathFill();
                    // select all county circles
                    const dotDensity = d3.selectAll(".dot");
                    // update radius, fill, and opacity properties of county circles
                    dotDensity
                        .transition()
                        .duration(this.transition.duration / 2)
                        .attr("r", (d) => {
                            const county = this.districtObj[d.id];
                            return county ? county.Size : 0;
                        })
                        .attr("fill", (d) => {
                            const county = this.districtObj[d.id];
                            return county
                                ? this.color(county["Percentage Point Difference"])
                                : "#ccc";
                        })
                        .style("opacity", 1);
                },
                createBars() {
                    const detailsLayer = d3.select("#details");
                    const share = [this.demShare, -this.gopShare];
                    const detailsBars = detailsLayer
                        .selectAll(".bar")
                        .data(share)
                        .enter()
                        .append("g")
                        .attr("class", "bar");

                    detailsBars
                        .append("rect")
                        .attr("width", 0)
                        .attr("height", 20)
                        .attr("x", 100)
                        .attr("y", 10)
                        .style("fill", this.color)
                        .transition()
                        .duration(this.transition.duration / 2)
                        .attr("x", (d) => (d > 0 ? 100 : 100 - this.wScale(-d)))
                        .attr("width", (d) => (d > 0 ? this.wScale(d) : this.wScale(-d)));

                    detailsBars
                        .append("text")
                        .text((d) =>
                            d > 0
                                ? `Dem. ${d3.format(".2%")(d)}`
                                : `Rep. ${d3.format(".2%")(-d)}`
                        )
                        .attr("x", 100)
                        .attr("dx", (d) => (d > 0 ? 5 : -5))
                        .attr("dy", 24)
                        .style("text-anchor", (d) => (d > 0 ? "start" : "end"))
                        .transition()
                        .duration(this.transition.duration / 2)
                        .attr("x", (d) =>
                            d > 0 ? 100 + this.wScale(d) : 100 - this.wScale(-d)
                        );
                },
                // adjust data bar on hover
                updateBars(d) {
                    const that = this;
                    const detailsLayer = d3.select("#details");
                    let share = [this.demShare, -this.gopShare];
                    let label = "Percentage Share of the Two-party Vote";

                    if (d) {
                        const county = this.districtObj[d.id];
                        if (county) {
                            share = [
                                county["% of Total Vote, Dem."],
                                -county["% of Total Vote, GOP"],
                            ];
                            label = `<tspan x="0" y="0">Percentage Point Difference: ${this.formatValue(
                                Math.abs(county["Percentage Point Difference"]),
                                "percent"
                            )}</tspan>`;
                        }
                    }

                    const detailsBars = detailsLayer.selectAll(".bar").data(share);

                    detailsBars
                        .select("rect")
                        .transition()
                        .duration(this.transition.duration / 2)
                        .attr("x", function (d) {
                            return d > 0 ? 100 : 100 - that.wScale(-d);
                        })
                        .attr("width", function (d) {
                            return d > 0 ? that.wScale(d) : that.wScale(-d);
                        })
                        .style("fill", this.color);

                    detailsBars
                        .select("text")
                        .text(this.showDiffLabel)
                        .transition()
                        .duration(this.transition.duration / 2)
                        .attr("x", function (d) {
                            return d > 0 ? 100 + that.wScale(d) : 100 - that.wScale(-d);
                        });

                    detailsLayer.select("#county-legend").html(label);
                },
                // define mouseover and mouseout events to ensure mouseover events work on IE
                bindHover() {
                    const that = this;
                    document.body.addEventListener("mousemove", function (e) {
                        const createTooltipTable = (county) => {
                            const value = that.formatValue(
                                county["Percentage Point Difference"],
                                "percent"
                            );
                            const dem_votes = that.formatValue(county["Dem."], "integer");
                            const gop_votes = that.formatValue(county["GOP"], "integer");
                            const votes_total = that.formatValue(
                                county["Total Votes"],
                                "integer"
                            );
                            const dem_pct = that.formatValue(
                                county["% of Total Vote, Dem."],
                                "percent"
                            );
                            const gop_pct = that.formatValue(
                                county["% of Total Vote, GOP"],
                                "percent"
                            );

                            const report_level =
                                '<div class="e-title">' +
                                county.County +
                                ", " +
                                county.State +
                                "</div>";

                            const startTable =
                                '<table class="tooltip-table" style="width: 100%; border-collapse: collapse;">';
                            const thead =
                                '<thead><tr><th></th><th>Candidate</th><th>Party</th><th style="text-align:right">Votes</th><th style="text-align:right">Pct.</th></tr></thead>';
                            const tbody = `<tbody><tr><td style="background-color:${that.color(
                                0.75
                            )}"></td><td>Kamala Harris</td><td>Dem.</td><td style="text-align:right">${dem_votes}</td><td style="text-align:right; font-weight:700">${dem_pct}</td></tr><tr><td style="background-color:${that.color(
                                -0.75
                            )}"></td><td>Donald J. Trump</td><td>Rep.</td><td style="text-align:right">${gop_votes}</td><td style="text-align:right; font-weight:700">${gop_pct}</td></tr><tr style="font-size:13px"><td></td><td><span><strong>All Votes</strong></span></td><td></td><td style="text-align:right"><span><strong>${votes_total}</strong></span></td><td style="text-align:right"></td></tr></tbody>`;
                            const endTable = "</table>";

                            // show tooltip with information from the __data__ property of the element
                            const content =
                                report_level + startTable + thead + tbody + endTable;

                            return content;
                        };

                        let content = "";
                        let d = null;
                        let county = null;

                        if (
                            (e.target.nodeName == "path" &&
                                e.target.className.animVal !== "state" &&
                                e.target.style.opacity == 1) ||
                            (e.target.nodeName == "circle" &&
                                e.target.className.animVal === "dot" &&
                                e.target.style.opacity == 1)
                        ) {
                            d = d3.select(e.target).data()[0];
                            county = that.districtObj[d.id];
                            content = createTooltipTable(county);
                        }

                        if (content) {
                            that.showDetail(e, content);
                            that.updateBars(d);
                        }
                    });

                    document.body.addEventListener("mouseout", function (e) {
                        if (
                            e.target.nodeName == "path" ||
                            e.target.nodeName == "circle"
                        ) {
                            that.hideDetail();
                            that.calculateMetrics();
                            that.updateBars(null);
                        }
                    });
                },
                // return percentage point labels for details bars
                showDiffLabel(d) {
                    return d > 0
                        ? `Dem. ${this.formatValue(d, "percent")}`
                        : `Rep. ${this.formatValue(-d, "percent")}`;
                },
                // Show tooltip on hover
                showDetail(event, content) {
                    // show tooltip with information from the __data__ property of the element
                    let x_hover = 0;
                    let y_hover = 0;

                    const tooltip = d3.select(".tooltip");

                    const tooltipWidth = parseInt(tooltip.style("width"));
                    const tooltipHeight = parseInt(tooltip.style("height"));
                    let classed, notClassed;

                    if (event.pageX > document.body.clientWidth / 2) {
                        x_hover = tooltipWidth + 30;
                        classed = "right";
                        notClassed = "left";
                    } else {
                        x_hover = -30;
                        classed = "left";
                        notClassed = "right";
                    }

                    y_hover =
                        document.body.clientHeight - event.pageY < tooltipHeight + 4
                            ? event.pageY - (tooltipHeight + 4)
                            : event.pageY - tooltipHeight / 2;

                    return tooltip
                        .classed(classed, true)
                        .classed(notClassed, false)
                        .style("visibility", "visible")
                        .style("top", y_hover + "px")
                        .style("left", event.pageX - x_hover + "px")
                        .html(content);
                },
                // Hide tooltip on hover
                hideDetail() {
                    const tooltip = d3.select(".tooltip");

                    // hide tooltip
                    return tooltip.style("visibility", "hidden");
                },
                formatValue(value, type) {
                    switch (type) {
                        case "integer":
                            return d3.format(",.0f")(value);
                        case "float":
                        case "percent":
                            return d3.format(".2%")(value);
                        default:
                            return value;
                    }
                },
                setResponsiveSVG() {
                    // Many browsers -- IE particularly -- will not auto-size inline SVG
                    // IE applies default width and height sizing
                    // padding-bottom hack on a container solves IE inconsistencies in size
                    // https://css-tricks.com/scale-svg/#article-header-id-10
                    const width = +d3.select("svg").attr("width");
                    const height = +d3.select("svg").attr("height");
                    const calcString = +(height / width) * 100 + "%";

                    const svgElement = d3.select("svg");
                    const svgParent = d3.select(d3.select("svg").node().parentNode);

                    svgElement
                        .attr("class", "scaling-svg")
                        .attr("preserveAspectRatio", "xMinYMin")
                        .attr("viewBox", "0 0 " + width + " " + height)
                        .attr("width", null)
                        .attr("height", null);

                    svgParent.style("padding-bottom", calcString);
                },
            },
        });
    </script>
    <script>
        (function (i, s, o, g, r, a, m) {
            i["GoogleAnalyticsObject"] = r;
            (i[r] =
                i[r] ||
                function () {
                    (i[r].q = i[r].q || []).push(arguments);
                }),
                (i[r].l = 1 * new Date());
            (a = s.createElement(o)), (m = s.getElementsByTagName(o)[0]);
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m);
        })(
            window,
            document,
            "script",
            "https://www.google-analytics.com/analytics.js",
            "ga"
        );

        ga("create", "UA-102235118-1", "auto");
        ga("send", "pageview");
    </script>
</body>

</html>